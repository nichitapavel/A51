Por DEFECTO:
0x12, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF

0x12 = 0001 0010 --- 0x23 = 0010 0011
0x45 = 0100 0101 --- 0x67 = 0110 0111
0x89 = 1000 1001 --- 0xAB = 1010 1011
0xCD = 1100 1101 --- 0xEF = 1110 1111

Como debería ser:
R1 = 0001 0010 0010 0011 010
R2 = 0010 1011 0011 1100 0100 11
R3 = 0101 0111 1001 1011 1101 111

Como es fase 1:
R1 = 1000 0000 0110 0001 101

R2 = X111 1110 1000 0001 0111 00
R3 = X110 1100 1101 0001 1100 001

Como es fase 2:
R1 = 1100 1001 0100 010
R2 = 1010 1111 0000 0011 1001 01
R3 = 1110 0101 1011 1111 0001 101

Como es fase 3:
R1 = XX11 1011 0100 1001 011
R2 = 1011 0010 1100 1011 1110 01
R3 = XXX1 0001 0111 1100 1011 111

*******************************************
Semilla PDF
Iter 0
1001 0001 0001 1010 001      - 297169
0101 1001 1110 0010 0110 10  - 1472666
1011 1100 1101 1110 0001 111 - 6188815

Iter 1
0010 0010 0011 0100 011      - 70051
1011 0011 1100 0100 1101 01  - 2945333
1011 1100 1101 1110 0001 111 - 6188815

Iter 2
0100 0100 0110 1000 111      - 140103
1011 0011 1100 0100 1101 01  - 2945333
0111 1001 1011 1100 0011 110 - 3989022

Iter 3
1000 1000 1101 0001 110      - 280206
1011 0011 1100 0100 1101 01  - 2945333
1111 0011 0111 1000 0111 100 - 7978044

Iter 4
0001 0001 1010 0011 101      - 36125
0110 0111 1000 1001 1010 11  - 1696363
1111 0011 0111 1000 0111 100 - 7978044

Iter 5
0010 0011 0100 0111 010      - 72250
0110 0111 1000 1001 1010 11  - 1696363
1110 0110 1111 0000 1111 001 - 7567481

0x91 = 1001 0001 --- 0x1A = 0001 1010
0x2B = 0010 1011 --- 0x3C = 0011 1100
0x4D = 0100 1101 --- 0x5E = 0101 1110
0x6F = 0110 1111 --- 0x0F = 0000 1111

0x91 0x1A 0x2B 0x3C 0x4D 0x5E 0x6F 0x0F

100 1000 1000 1101 0001 = 0x04 0x88 0xD1
01 0110 0111 1000 1001 1010 = 0x16 0x78 0x9A
101 1110 0110 1111 0000 1111 = 0x5E 0x6F 0x0F

for (i=0; i<19; i++) {
                clock(1,0); /* always clock */ //Mover hacia izquierda los registros
                keybit = (key[i/8] >> (i&7)) & 1; /* The i-th bit of the key */ //se coge el bit más de la derecha del byte
                //se mueve el byte para coger el siguiente bit
                R1 ^= keybit; R2 ^= keybit; R3 ^= keybit; //se hace un XOR con el bit sacado en cada registro
        }

        for (i=0; i<22; i++) {
                clock(1,0); /* always clock */ //Mover hacia izquierda los registros
                keybit = (key[i/8] >> (i&7)) & 1; /* The i-th bit of the key */ //se coge el bit más de la derecha del byte
                //se mueve el byte para coger el siguiente bit
                R1 ^= keybit; R2 ^= keybit; R3 ^= keybit; //se hace un XOR con el bit sacado en cada registro
        }

        for (i=0; i<23; i++) {
                clock(1,0); /* always clock */ //Mover hacia izquierda los registros
                keybit = (key[i/8] >> (i&7)) & 1; /* The i-th bit of the key */ //se coge el bit más de la derecha del byte
                //se mueve el byte para coger el siguiente bit
                R1 ^= keybit; R2 ^= keybit; R3 ^= keybit; //se hace un XOR con el bit sacado en cada registro
        }
